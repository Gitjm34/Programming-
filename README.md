# 🃏 Blackjack Game (블랙잭 게임)

## 📌 프로젝트 개요
본 프로젝트는 객체지향 설계 패턴을 적용한 블랙잭 게임입니다. 
사용자 로그인, 카드 분배, 점수 계산, 승패 결정 등을 **커맨드 패턴(Command Pattern)**을 활용하여 구현하였습니다. 또한, **팩토리 패턴(Factory Pattern)**을 사용하여 명령을 관리하며, **싱글톤 패턴(Singleton Pattern)**을 적용하여 `CommandFactory` 클래스가 두 개 이상 생성되지 않도록 설계되었습니다.

---

## 🛠 시스템 구성 요소

### 🔹 User 클래스
- 사용자 정보 관리: 사용자 ID, 비밀번호, 이름, 보유 점수, 손패 카드(`cardsInHand`)
- 보유 카드 점수 계산 기능 포함

### 🔹 Card 클래스
- 카드 정보 관리: 카드의 무늬(`suit`), 숫자(`value`)

### 🔁 Command 패턴을 적용한 주요 기능
#### 1️⃣ InitialCardDistribution (초기 카드 배포)
- 모든 플레이어에게 카드 2장을 배포
- 카드를 랜덤하게 섞고(Shuffle) 리스트에서 배포

#### 2️⃣ PersonalHitRequest (카드 추가 요청)
- 플레이어가 요청하면 카드 한 장을 추가 지급
- 카드 리스트(큐)에서 카드 한 장을 제공

#### 3️⃣ CheckLoser (패배자 확인 및 제거)
- 카드 합산 점수가 21을 초과한 플레이어를 패배 처리
- 패배한 플레이어의 점수를 0으로 설정 후 게임에서 제외
- 패배한 플레이어를 우선순위 큐에 저장하여 등수를 관리

#### 4️⃣ CheckWinner (승리자 판별 및 점수 배당)
- 게임이 끝난 후 남아있는 플레이어들의 점수 계산
- 승리자에게 패배한 플레이어의 배당 점수를 지급
- 다수의 승리자가 존재하는 경우 점수 균등 분배

#### 5️⃣ Replay (리플레이 시스템)
- 이전 게임의 모든 `Command`들을 저장하여 재실행 가능
- 저장된 커맨드를 순차적으로 실행하여 게임 재현

---

## 🎮 게임 플레이 흐름
1️⃣ 게임 시작 전 56장의 카드를 생성 후 셔플  
2️⃣ 로그인한 사용자들에게 카드 2장씩 배포  
3️⃣ 플레이어의 점수를 확인하여 패배자 제거 (21 초과 시 패배)  
4️⃣ 남은 플레이어들에게 추가 카드 요청 기회 제공  
5️⃣ 추가 카드를 받은 후 패배 여부 재확인  
6️⃣ 모든 플레이어가 카드를 받지 않으면 승자 및 점수 계산  
7️⃣ 패배자의 배당 점수를 승자에게 지급  
8️⃣ 전원 패배 시 모든 플레이어의 점수 차감  
9️⃣ 전원 승리 시 점수 변화 없음 (무승부 처리)  
🔟 게임 종료 후 리플레이 기능 제공  

---

## 📂 파일 입출력 시스템
✅ **User 정보 파일**: `User_id password username remainScore` 형식으로 저장  
✅ **게임 결과 저장 및 불러오기 가능**

#### 📌 예시 데이터:
```yaml
1 pw1 홍길동 10000
2 pw2 김철수 9800
```

---

## 🏛 디자인 패턴 적용
### 🔹 Command 패턴
- 플레이어의 행동(카드 요청, 승패 판별 등)을 `Command` 객체로 처리
- `Invoker`를 통해 명령을 실행하여 재사용성 및 유지보수성을 높임

### 🔹 Factory 패턴
- `Command` 객체 생성을 중앙에서 관리
- `Command ID`를 입력받아 적절한 `Command` 객체를 반환

### 🔹 Singleton 패턴
- `CommandFactory`를 싱글톤으로 구현하여 두 개 이상 유지되지 않도록 관리

---

## 🎨 추가 기능
✅ **AI와 플레이하기**: AI 상대 추가하여 1인 플레이 가능  
✅ **리플레이 저장**: 게임 기록을 파일로 저장하여 추후 분석 가능  

---

## 🔗 프로젝트 코드 및 실행 방법
📌 **GitHub Repository**: [Blackjack Game 프로젝트](https://github.com/your-repository-link)  
📌 **프로젝트 코드 및 실행 방법**은 해당 저장소에서 확인 가능합니다.





---





# 🌯 부리또 매장 관리 프로그램

## 📌 프로젝트 개요
부리또 매장 관리 프로그램을 설계 및 구현하는 프로젝트입니다. 
**팩토리 패턴(Factory Pattern)**과 **데코레이터 패턴(Decorator Pattern)**을 활용하여 주문 및 관리를 효율적으로 수행하도록 설계되었습니다.

---

## 🛠 시스템 구성 요소

### 🔹 주요 클래스 및 역할
- `App`: `BuritoFactory`와 `TransactionManager`를 포함하여 실행을 담당합니다.
- `BuritoFactory`: 팩토리 패턴을 적용하여 주문받은 메뉴를 생성합니다.
- `TransactionManager`: 주문 내역을 관리합니다.
- `Burito`: 데코레이터 패턴을 구현한 기본 부리또 클래스입니다.
- `BaseBurito`: 기본 부리또 구성 요소입니다.
- `Decorator`: 추가 재료 및 할인 정보를 적용하기 위한 클래스입니다.
- `Jumbo, Sausage, Drink, Fries`: 추가 재료 데코레이터 클래스입니다.
- `ComboDiscount, SetDiscount`: 할인 데코레이터 클래스입니다.

### 🔹 주요 기능
- 주문 추가 및 처리
- 주문 취소
- 주문 목록 조회 및 관리
- 데이터 파일(txt)에서 주문 내역 적재

---

## 🎮 프로그램 실행 흐름
1️⃣ 프로그램 실행 시 `txt` 파일에서 기존 주문 내역을 불러옵니다.  
2️⃣ 사용자에게 현재 받은 주문 목록을 표시합니다.  
3️⃣ 사용자는 다음 기능을 수행할 수 있습니다:
   - 주문 추가
   - 주문 처리
   - 주문 취소
4️⃣ 주문 처리 시, 가장 앞의 주문이 처리되며 내역이 갱신됩니다.  
5️⃣ 주문이 완료되면 결과가 저장됩니다.

---

## 📂 파일 입출력 시스템
✅ **Order DB**: 주문 내역을 저장하고 로드할 수 있습니다.

#### 📌 예시 데이터:
```yaml
1 Burito_Sausage + Drink 7500
2 Burito_Jumbo + Fries + SetDiscount 8800
```

---

## 🏛 디자인 패턴 적용
### 🔹 Factory 패턴
- `BuritoFactory`에서 주문받은 메뉴를 생성합니다.

### 🔹 Decorator 패턴
- `Burito`를 기반으로 추가 재료 및 할인 옵션을 적용합니다.

---

## 🔗 프로젝트 코드 및 실행 방법
📌 **GitHub Repository**: [Burito Store Management 프로젝트](https://github.com/your-repository-link)  
📌 **프로젝트 코드 및 실행 방법**은 해당 저장소에서 확인 가능합니다.

---

